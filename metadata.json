{
  "0020": {
    "difficulty": "Easy",
    "notes": "使用栈（Stack）是解决此问题的经典方法。遍历字符串，遇到左括号入栈，遇到右括号则与栈顶元素匹配出栈。"
  },
  "0021": {
    "difficulty": "Easy",
    "notes": "迭代法使用虚拟头节点（dummy node）简化链表操作；递归法则代码更简洁。"
  },
  "0022": {
    "difficulty": "Medium",
    "notes": "回溯法是解决此问题的标准解法。通过剪枝优化：当左括号数量未满n时可添加 '('；当右括号数量小于左括号时可添加 ')'，从而确保所有组合都有效。"
  },
  "0023": {
    "difficulty": "Hard",
    "notes": "暴力法​​直接收集排序，简单但低效；​​顺序合并法​​通过两两合并简化问题，易于理解；​​分治法​​应用归并思想，达到O(N log k)最优时间复杂度，稳定可靠；​​优先队列法​​利用最小堆动态获取最小值，代码简洁，面试首选。"
  },
  "0024": {
    "difficulty": "Medium",
    "notes": "迭代法可借助虚拟头节点，通过指针操作两两交换节点。递归法则将问题分解为“交换当前两个节点”和“处理剩余链表”的子问题，逻辑更清晰。"
  },
  "0025": {
    "difficulty": "Hard",
    "notes": "“反转链表”的升级版。核心思路是分组处理，然后将其与前后部分连接起来。需要精细控制多个指针。"
  },
  "0026": {
    "difficulty": "Easy",
    "notes": "使用双指针解法--快慢指针。"
  },
  "0027": {
    "difficulty": "Easy",
    "notes": "快慢指针的本质是将所有不需要移除的元素，按照原有的相对顺序，全部搬运到了数组的前面。 首位双指针（对撞指针）的方法相较与快慢指针的优势在于大幅减少了元素的赋值次数，仅在遇到目标元素时才操作，但会打乱元素的原始相对顺序。"
  },
  "0028": {
    "difficulty": "Easy",
    "notes": "暴力法简单但是低效，不适合大量长文本的字符串匹配。kmp算法只需遍历一遍字符串"
  },
  "0070": {
    "difficulty": "Easy",
    "notes": ""
  },
  "0094": {
    "difficulty": "Easy",
    "notes": "递归法 : 这是最直观、代码最简洁的解法。迭代法: 使用一个栈来模拟递归的过程。通过循环和栈的辅助，手动控制节点的访问顺序，有效避免了当树的深度过大时可能出现的栈溢出问题。Morris 遍历: 一种空间复杂度为 O(1) 的精妙解法。它不使用递归和栈，而是通过临时修改树中节点的右空指针，建立起“线索”，从而在遍历完左子树后能够顺利地回溯到根节点。"
  },
  "0101": {
    "difficulty": "Easy",
    "notes": "![image-20251020105336646](https://lskypro.puber.top/i/2025/10/20/68f5a437bb933.png) 递归解法通常是深度优先（DFS）的顺序。它会沿着一条路径深入下去，连续访问的节点（父、子、孙）在内存中的位置可能更接近。迭代解法是广度优先（BFS）的顺序。它在树的各层之间“跳跃”，访问的内存地址可能不连续。"
  },
  "0104": {
    "difficulty": "Easy",
    "notes": ""
  },
  "0226": {
    "difficulty": "Easy",
    "notes": ""
  },
  "0102": {
    "difficulty": "Medium",
    "notes": "使用bfs实现二叉树的层序遍历"
  },
  "0136": {
    "difficulty": "Easy",
    "notes": "题目要求只使用常量的额外空间，所以不能使用哈希表存储每个数字出现的次数。本题利用了异或运算的性质，a ^ a = 0, 0 ^ a = a"
  },
  "0069": {
    "difficulty": "Easy",
    "notes": "可以使用二分查找方，也可以使用牛顿迭代法。[牛顿迭代法详解](https://oi-wiki.org/math/numerical/newton/)"
  },
  "0067": {
    "difficulty": "Easy",
    "notes": "使用模拟法从字符串的尾部逐个相加到头部，使用StringBuilder保存相加结果，返回时候将StringBuilder反转即为最后的结果。模拟法的优点是不会遇到整数溢出的问题。"
  },
  "0029": {
    "difficulty": "Medium",
    "notes": "该算法通过位运算实现整数除法，核心是处理符号后转为负数计算以避免溢出，并通过位移加速减法过程。关键点包括处理 Integer.MIN_VALUE / -1的溢出，以及内层循环中检查位移边界防止溢出"
  },
  "0035": {
    "difficulty": "Easy",
    "notes": "题目要求必须使用时间复杂度为 O(log n) 的算法，下意识想到二分查找的方法。"
  },
  "0045": {
    "difficulty": "Medium",
    "notes": ""
  },
  "0046": {
    "difficulty": "Medium",
    "notes": "使用回溯算法生成数组的全部排列，通过used数组标记已选元素避免重复，并在找到完整排列时保存路径副本，确保结果正确。其时间复杂度为O(n × n!)"
  },
  "0047": {
    "difficulty": "Medium",
    "notes": "在 46 题回溯算法的基础上，增加了对重复元素排列的去重处理。关键在于先对数组排序，然后在回溯的 for 循环中增加剪枝逻辑（i > 0 && nums[i] == nums[i-1] && !used[i-1]），确保相同元素在同一层只被选择一次，避免产生重复排列。时间复杂度仍为 O(n × n!)。"
  },
  "0048": {
    "difficulty": "Medium",
    "notes": "原地旋转矩阵。使用'分解动作'的技巧，将一次复杂的'顺时针旋转90度'分解为两次简单的原地操作：1. 先沿主对角线（左上到右下）翻转矩阵；2. 再对矩阵的每一行进行左右水平翻转。"
  }
}