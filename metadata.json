{
  "0020": {
    "difficulty": "Easy",
    "notes": "使用栈（Stack）是解决此问题的经典方法。遍历字符串，遇到左括号入栈，遇到右括号则与栈顶元素匹配出栈。"
  },
  "0021": {
    "difficulty": "Easy",
    "notes": "迭代法使用虚拟头节点（dummy node）简化链表操作；递归法则代码更简洁。"
  },
  "0022": {
    "difficulty": "Medium",
    "notes": "回溯法是解决此问题的标准解法。通过剪枝优化：当左括号数量未满n时可添加 '('；当右括号数量小于左括号时可添加 ')'，从而确保所有组合都有效。"
  },
  "0023": {
    "difficulty": "Hard",
    "notes": "暴力法​​直接收集排序，简单但低效；​​顺序合并法​​通过两两合并简化问题，易于理解；​​分治法​​应用归并思想，达到O(N log k)最优时间复杂度，稳定可靠；​​优先队列法​​利用最小堆动态获取最小值，代码简洁，面试首选。"
  },
  "0024": {
    "difficulty": "Medium",
    "notes": "迭代法可借助虚拟头节点，通过指针操作两两交换节点。递归法则将问题分解为“交换当前两个节点”和“处理剩余链表”的子问题，逻辑更清晰。"
  },
  "0025": {
    "difficulty": "Hard",
    "notes": "“反转链表”的升级版。核心思路是分组处理，然后将其与前后部分连接起来。需要精细控制多个指针。"
  },
  "0026": {
    "difficulty": "Easy",
    "notes": "使用双指针解法--快慢指针。"
  },
  "0027": {
    "difficulty": "Easy",
    "notes": "快慢指针的本质是将所有不需要移除的元素，按照原有的相对顺序，全部搬运到了数组的前面。 首位双指针（对撞指针）的方法相较与快慢指针的优势在于大幅减少了元素的赋值次数，仅在遇到目标元素时才操作，但会打乱元素的原始相对顺序。"
  },
  "0028": {
    "difficulty": "Easy",
    "notes": "暴力法简单但是低效，不适合大量长文本的字符串匹配。kmp算法只需遍历一遍字符串"
  },
  "0070": {
    "difficulty": "Easy",
    "notes": ""
  },
  "0094": {
    "difficulty": "Easy",
    "notes": "递归法 : 这是最直观、代码最简洁的解法。迭代法: 使用一个栈来模拟递归的过程。通过循环和栈的辅助，手动控制节点的访问顺序，有效避免了当树的深度过大时可能出现的栈溢出问题。Morris 遍历: 一种空间复杂度为 O(1) 的精妙解法。它不使用递归和栈，而是通过临时修改树中节点的右空指针，建立起“线索”，从而在遍历完左子树后能够顺利地回溯到根节点。"
  },
  "0101": {
    "difficulty": "Easy",
    "notes": "![image-20251020105336646](https://lskypro.puber.top/i/2025/10/20/68f5a437bb933.png) 递归解法通常是深度优先（DFS）的顺序。它会沿着一条路径深入下去，连续访问的节点（父、子、孙）在内存中的位置可能更接近。迭代解法是广度优先（BFS）的顺序。它在树的各层之间“跳跃”，访问的内存地址可能不连续。"
  },
  "0104": {
    "difficulty": "Easy",
    "notes": ""
  },
  "0226": {
    "difficulty": "Easy",
    "notes": ""
  },
  "0102": {
    "difficulty": "Medium",
    "notes": "使用bfs实现二叉树的层序遍历"
  },
  "0136": {
    "difficulty": "Easy",
    "notes": "题目要求只使用常量的额外空间，所以不能使用哈希表存储每个数字出现的次数。本题利用了异或运算的性质，a ^ a = 0, 0 ^ a = a"
  },
  "0069": {
    "difficulty": "Easy",
    "notes": "可以使用二分查找方，也可以使用牛顿迭代法。[牛顿迭代法详解](https://oi-wiki.org/math/numerical/newton/)"
  },
  "0067": {
    "difficulty": "Easy",
    "notes": "使用模拟法从字符串的尾部逐个相加到头部，使用StringBuilder保存相加结果，返回时候将StringBuilder反转即为最后的结果。模拟法的优点是不会遇到整数溢出的问题。"
  },
  "0029": {
    "difficulty": "Medium",
    "notes": "该算法通过位运算实现整数除法，核心是处理符号后转为负数计算以避免溢出，并通过位移加速减法过程。关键点包括处理 Integer.MIN_VALUE / -1的溢出，以及内层循环中检查位移边界防止溢出"
  },
  "0035": {
    "difficulty": "Easy",
    "notes": "题目要求必须使用时间复杂度为 O(log n) 的算法，下意识想到二分查找的方法。"
  },
  "0045": {
    "difficulty": "Medium",
    "notes": ""
  },
  "0046": {
    "difficulty": "Medium",
    "notes": "使用回溯算法生成数组的全部排列，通过used数组标记已选元素避免重复，并在找到完整排列时保存路径副本，确保结果正确。其时间复杂度为O(n × n!)"
  },
  "0047": {
    "difficulty": "Medium",
    "notes": "在 46 题回溯算法的基础上，增加了对重复元素排列的去重处理。关键在于先对数组排序，然后在回溯的 for 循环中增加剪枝逻辑（i > 0 && nums[i] == nums[i-1] && !used[i-1]），确保相同元素在同一层只被选择一次，避免产生重复排列。时间复杂度仍为 O(n × n!)。"
  },
  "0048": {
    "difficulty": "Medium",
    "notes": "原地旋转矩阵。使用'分解动作'的技巧，将一次复杂的'顺时针旋转90度'分解为两次简单的原地操作：1. 先沿主对角线（左上到右下）翻转矩阵；2. 再对矩阵的每一行进行左右水平翻转。"
  },
  "0050": {
    "difficulty": "Medium",
    "notes": "实现 pow(x, n)。考察快速幂算法（Exponentiation by Squaring）。关键思路：当 n 为偶数时，pow(x, n) = pow(x*x, n/2)；当 n 为奇数时，pow(x, n) = x * pow(x, n-1)。通过递归或迭代方式实现，时间复杂度从 O(n) 降到 O(log n)。注意处理 n 为负数的情况（结果取 1/pow(x, -n)）。"
  },
  "0054": {
    "difficulty": "Medium",
    "notes": "方法一：模拟转圈法：使用方向数组并标记访问过的元素，通过转向规则控制遍历。方法二：方向向量旋转模拟法，通过旋转方向向量实现顺时针遍历矩阵。![image-20251024200657296](https://lskypro.puber.top/i/2025/10/24/68fb6be8ed224.png)"
  },
  "0061": {
    "difficulty": "Medium",
    "notes": "使用成环破环法解决，先成环，然后计算偏移量，然后在偏移后的位置破环"
  },
  "0063": {
    "difficulty": "Medium",
    "notes": ""
  },
  "0058": {
    "difficulty": "Easy",
    "notes": "题目是求字符串的最后一个单词的长度，所以此题的关键就是从字符串的尾部开始遍历"
  },
  "0077": {
    "difficulty": "Medium",
    "notes": "看到这类组合问题，第一反应就是使用回溯法来解决。关键在于如何设计回溯函数的参数和终止条件。这里我们敏锐的察觉到所有的组合都是递增的，所以可以使用一个start索引来控制每次选择的起点，避免重复选择和无效选择。"
  },
  "0059": {
    "difficulty": "Medium",
    "notes": ""
  },
  "0083": {
    "difficulty": "Easy",
    "notes": "设定一个指针遍历链表，当当前节点的值等于下一个节点的值时，跳过下一个节点，直到遇到不同值的节点为止。这样就能有效地移除重复节点，保持链表的唯一性。"
  },
  "0066": {
    "difficulty": "Easy",
    "notes": ""
  },
  "0100": {
    "difficulty": "Easy",
    "notes": "递归是深度优先的方法，迭代是广度优先的方法。迭代方法使用的队列是LinkedList实现的，可以存储null节点，而ArrayDeque不可以存储null节点。"
  },
  "0118": {
    "difficulty": "Easy",
    "notes": "这道杨辉三角的题主要是要用到List的get方法来获取上一行的元素，从而计算出当前行的元素值。"
  },
  "0290": {
    "difficulty": "Easy",
    "notes": "这道题的关键是如何保证模式字符串中的字符和字符串中的单词间的一一对应关系。为此，我们使用了两个哈希表：一个用于存储字符到单词的映射，另一个用于存储单词到字符的映射。在遍历模式字符串和字符串时，我们同时检查这两个映射表，以确保每个字符和单词之间的映射关系是一致的。如果发现任何不一致的情况，我们就返回false。如果遍历完成后没有发现不一致的映射关系，则返回true，表示字符串遵循给定的模式。另外一个需要注意的就是注意模式串的长度和字符串中的单词个数是否一致，不一致的话直接返回false。"
  },
  "2125": {
    "difficulty": "Medium",
    "notes": "标准答案使用了函数编程的思想，使用了int cnt = (int) line.chars().filter(ch -> ch == '1').count()来统计每一行中'1'的个数，非常简洁。另一种思路是使用传统的for循环遍历字符串，遇到'1'就计数器加一。"
  },
  "0200": {
    "difficulty": "Medium",
    "notes": ""
  },
  "0036": {
    "difficulty": "Medium",
    "notes": "核心思路是通过一次遍历，使用数组（或哈希集合）分别记录每行、每列、每个3x3宫格中数字的出现情况。关键点是计算宫格索引：box_index = (i // 3) * 3 + j // 3。优化方向包括使用位运算压缩空间。"
  },
  "0039": {
    "difficulty": "Medium",
    "notes": "组合总和问题。核心解法：回溯算法。关键点：1) 数字可无限次使用，递归时起始索引传入i而非i+1；2) 通过控制起始索引避免重复组合（从start开始而非0）；3) 可先排序数组，在循环中增加current_sum + candidates[i] <= target条件进行剪枝优化。时间复杂度：O(N^(T/M+1))，其中N为候选数个数，T为目标数，M为最小候选数。"
  },
  "0040": {
    "difficulty": "Medium",
    "notes": "组合总和II，是39题的变体。关键区别：1) 每个数字只能使用一次，递归时起始索引传入i+1；2) 数组可能包含重复元素，需要额外去重处理。核心解法：排序+回溯+同层去重。去重技巧：if(i > start && candidates[i] == candidates[i-1]) continue; 确保同一层级不选择相同数字。必须排序，这是去重的前提条件。"
  },
  "0071": {
    "difficulty": "Medium",
    "notes": "根据题意，遇到'..'需要回退到上一级目录，于是我们自然想到栈后进先出的特性，使用栈（Stack）数据结构来处理路径简化问题。遍历路径字符串，遇到'..'时弹出栈顶元素（表示返回上一级目录），遇到'.'或空字符串时忽略，其他有效目录名则入栈。最后将栈中的元素拼接成简化后的路径。ArrayList不是栈结构，但是如果只使用add和removeLast方法，也可以模拟栈的行为。"
  },
  "3289": {
    "difficulty": "Easy",
    "notes": "这题如果要使用额外空间的话，可以使用哈希集合（HashSet）来记录已经出现过的数字，然后在遍历数组时检查当前数字是否已经在集合中出现过，从而找到重复的数字。对于缺失的数字，可以通过计算总和的方式来找出。另一种不使用额外空间的方法是利用数组本身作为哈希表，通过将数字对应的索引位置加上N（数组长度）作为标记，从而找到重复和缺失的数字。"
  },
  "3217": {
    "difficulty": "Medium",
    "notes": "题目要求删去链表中所有在数组中出现的节点。可以使用哈希集合（HashSet）存储数组中的值，以便快速查找。然后遍历链表，使用双指针（前驱节点和当前节点）来删除匹配的节点。为了简化边界情况的处理（头结点可能被移除），可以引入一个虚拟头节点（dummy node）。"
  },
  "2257": {
    "difficulty": "Medium",
    "notes": "使用模拟法解决守卫保护单元格的问题。首先构建一个矩阵表示网格状态，标记守卫和墙的位置。然后对于每个守卫，沿四个方向（上、下、左、右）遍历，直到遇到墙或另一个守卫，标记这些路径上的单元格为受保护状态。最后统计未被保护且非墙非守卫的单元格数量。关键点在于正确处理边界条件和避免重复标记。"
  },
  "3732": {
    "difficulty": "Medium",
    "notes": "这道题的关键是要找到nums中绝对值最大和第二大的元素，然后根据它们的符号来决定最终的最大正数和最小负数。具体步骤如下：首先初始化前两个元素，确保firstMax的绝对值不小于secondMax；接着从第三个元素开始遍历，若当前元素绝对值大于firstMax，则更新secondMax为原firstMax，并更新firstMax为当前元素；若其绝对值仅大于secondMax，则只更新secondMax。"
  }
}