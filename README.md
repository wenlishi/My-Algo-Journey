# My Algo Journey

此代码库记录了我的 LeetCode 算法与数据结构学习之旅。它不仅是我的个人解题日志，更是日后参考的知识宝库，旨在不断磨练逻辑思维，精进编程技艺。

## Progress

| # | Title | Solution | Difficulty | Notes |
|---|---|---|---|---|
| 0020 | [Valid Parentheses](https://leetcode.cn/problems/valid-parentheses/) | [Java(Stackandmap)](0020-valid-parentheses/Solution_StackAndMap.java), [Java(Stackonly)](0020-valid-parentheses/Solution_StackOnly.java) | Easy | 使用栈（Stack）是解决此问题的经典方法。遍历字符串，遇到左括号入栈，遇到右括号则与栈顶元素匹配出栈。 |
| 0021 | [Merge Two Sorted Lists](https://leetcode.cn/problems/merge-two-sorted-lists/) | [Java(Iteration)](0021-merge-two-sorted-lists/Solution_Iteration.java), [Java(Recursion)](0021-merge-two-sorted-lists/Solution_Recursion.java) | Easy | 迭代法使用虚拟头节点（dummy node）简化链表操作；递归法则代码更简洁。 |
| 0022 | [Generate Parentheses](https://leetcode.cn/problems/generate-parentheses/) | [Java(Pruningbacktrack)](0022-generate-parentheses/Solution_PruningBacktrack.java), [Java(Recursion)](0022-generate-parentheses/Solution_Recursion.java) | Medium | 回溯法是解决此问题的标准解法。通过剪枝优化：当左括号数量未满n时可添加 '('；当右括号数量小于左括号时可添加 ')'，从而确保所有组合都有效。 |
| 0023 | [Merge K Sorted Lists](https://leetcode.cn/problems/merge-k-sorted-lists/) | [Java(Bruteforce)](0023-merge-k-sorted-lists/Solution_BruteForce.java), [Java(Divideandconquer)](0023-merge-k-sorted-lists/Solution_DivideAndConquer.java), [Java(Priorityqueue)](0023-merge-k-sorted-lists/Solution_PriorityQueue.java), [Java(Sequentialmerge)](0023-merge-k-sorted-lists/Solution_SequentialMerge.java) | Hard | 暴力法​​直接收集排序，简单但低效；​​顺序合并法​​通过两两合并简化问题，易于理解；​​分治法​​应用归并思想，达到O(N log k)最优时间复杂度，稳定可靠；​​优先队列法​​利用最小堆动态获取最小值，代码简洁，面试首选。 |
| 0024 | [Swap Nodes In Pairs](https://leetcode.cn/problems/swap-nodes-in-pairs/) | [Java(Iteration)](0024-swap-nodes-in-pairs/Solution_Iteration.java), [Java(Recursion)](0024-swap-nodes-in-pairs/Solution_Recursion.java) | Medium | 迭代法可借助虚拟头节点，通过指针操作两两交换节点。递归法则将问题分解为“交换当前两个节点”和“处理剩余链表”的子问题，逻辑更清晰。 |
| 0025 | [Reverse Nodes In K Group](https://leetcode.cn/problems/reverse-nodes-in-k-group/) | [Java(Iteration)](0025-reverse-nodes-in-k-group/Solution_Iteration.java) | Hard | “反转链表”的升级版。核心思路是分组处理，然后将其与前后部分连接起来。需要精细控制多个指针。 |
| 0026 | [Remove Duplicates From Sorted Array](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/) | [Java(Fastslowpointer)](0026-remove-duplicates-from-sorted-array/Solution_FastSlowPointer.java) | Easy | 使用双指针解法--快慢指针。 |
| 0027 | [Remove Element](https://leetcode.cn/problems/remove-element/) | [Java(Fastslowpointer)](0027-remove-element/Solution_FastSlowPointer.java), [Java(Twopointersfromoppositeends)](0027-remove-element/Solution_TwoPointersFromOppositeEnds.java) | Easy | 快慢指针的本质是将所有不需要移除的元素，按照原有的相对顺序，全部搬运到了数组的前面。 首位双指针（对撞指针）的方法相较与快慢指针的优势在于大幅减少了元素的赋值次数，仅在遇到目标元素时才操作，但会打乱元素的原始相对顺序。 |
| 0028 | [Find The Index Of The First Occurrence In A String](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/) | [Java(Iteration)](0028-find-the-index-of-the-first-occurrence-in-a-string/Solution_Iteration.java), [Java(Kmp)](0028-find-the-index-of-the-first-occurrence-in-a-string/Solution_Kmp.java) | Easy | 暴力法简单但是低效，不适合大量长文本的字符串匹配。kmp算法只需遍历一遍字符串 |
| 0029 | [Divide Two Integers](https://leetcode.cn/problems/divide-two-integers/) | [Java(Bitwisedivision)](0029-divide-two-integers/Solution_BitwiseDivision.java) | Medium | 该算法通过位运算实现整数除法，核心是处理符号后转为负数计算以避免溢出，并通过位移加速减法过程。关键点包括处理 Integer.MIN_VALUE / -1的溢出，以及内层循环中检查位移边界防止溢出 |
| 0035 | [Search Insert Position](https://leetcode.cn/problems/search-insert-position/) | [Java(Binarysearch)](0035-search-insert-position/Solution_BinarySearch.java) | Easy | 题目要求必须使用时间复杂度为 O(log n) 的算法，下意识想到二分查找的方法。 |
| 0036 | [Valid Sudoku](https://leetcode.cn/problems/valid-sudoku/) | [Java(Bitwiseoperation)](0036-valid-sudoku/Solution_BitwiseOperation.java), [Java(Mymethod)](0036-valid-sudoku/Solution_MyMethod.java) | Medium | 核心思路是通过一次遍历，使用数组（或哈希集合）分别记录每行、每列、每个3x3宫格中数字的出现情况。关键点是计算宫格索引：box_index = (i // 3) * 3 + j // 3。优化方向包括使用位运算压缩空间。 |
| 0039 | [Combination Sum](https://leetcode.cn/problems/combination-sum/) | [Java(Backtrack)](0039-combination-sum/Solution_Backtrack.java) | Medium | 组合总和问题。核心解法：回溯算法。关键点：1) 数字可无限次使用，递归时起始索引传入i而非i+1；2) 通过控制起始索引避免重复组合（从start开始而非0）；3) 可先排序数组，在循环中增加current_sum + candidates[i] <= target条件进行剪枝优化。时间复杂度：O(N^(T/M+1))，其中N为候选数个数，T为目标数，M为最小候选数。 |
| 0040 | [Combination Sum Ii](https://leetcode.cn/problems/combination-sum-ii/) | [Java(Backtrack)](0040-combination-sum-ii/Solution_Backtrack.java) | Medium | 组合总和II，是39题的变体。关键区别：1) 每个数字只能使用一次，递归时起始索引传入i+1；2) 数组可能包含重复元素，需要额外去重处理。核心解法：排序+回溯+同层去重。去重技巧：if(i > start && candidates[i] == candidates[i-1]) continue; 确保同一层级不选择相同数字。必须排序，这是去重的前提条件。 |
| 0045 | [Jump Game Ii](https://leetcode.cn/problems/jump-game-ii/) | [Java(Bfs)](0045-jump-game-ii/Solution_Bfs.java), [Java(Greedy)](0045-jump-game-ii/Solution_Greedy.java) | Medium |  |
| 0046 | [Permutations](https://leetcode.cn/problems/permutations/) | [Java(Backtrack)](0046-permutations/Solution_Backtrack.java) | Medium | 使用回溯算法生成数组的全部排列，通过used数组标记已选元素避免重复，并在找到完整排列时保存路径副本，确保结果正确。其时间复杂度为O(n × n!) |
| 0047 | [Permutations Ii](https://leetcode.cn/problems/permutations-ii/) | [Java(Backtrack)](0047-permutations-ii/Solution_Backtrack.java) | Medium | 在 46 题回溯算法的基础上，增加了对重复元素排列的去重处理。关键在于先对数组排序，然后在回溯的 for 循环中增加剪枝逻辑（i > 0 && nums[i] == nums[i-1] && !used[i-1]），确保相同元素在同一层只被选择一次，避免产生重复排列。时间复杂度仍为 O(n × n!)。 |
| 0048 | [Rotate Image](https://leetcode.cn/problems/rotate-image/) | [Java(Transposeandreverse)](0048-rotate-image/Solution_TransposeAndReverse.java) | Medium | 原地旋转矩阵。使用'分解动作'的技巧，将一次复杂的'顺时针旋转90度'分解为两次简单的原地操作：1. 先沿主对角线（左上到右下）翻转矩阵；2. 再对矩阵的每一行进行左右水平翻转。 |
| 0050 | [Powx N](https://leetcode.cn/problems/powx-n/) | [Java(Iterationfastpower)](0050-powx-n/Solution_IterationFastPower.java), [Java(Mymethod)](0050-powx-n/Solution_MyMethod.java), [Java(​​Recursive​​Fastpower)](0050-powx-n/Solution_​​Recursive​​FastPower.java) | Medium | 实现 pow(x, n)。考察快速幂算法（Exponentiation by Squaring）。关键思路：当 n 为偶数时，pow(x, n) = pow(x*x, n/2)；当 n 为奇数时，pow(x, n) = x * pow(x, n-1)。通过递归或迭代方式实现，时间复杂度从 O(n) 降到 O(log n)。注意处理 n 为负数的情况（结果取 1/pow(x, -n)）。 |
| 0053 | [Maximum Subarray](https://leetcode.cn/problems/maximum-subarray/) | [Java(Mymethod)](0053-maximum-subarray/Solution_MyMethod.java), [Java(Onedimensionalarraydp)](0053-maximum-subarray/Solution_OneDimensionalArrayDP.java) | Medium | 核心是动态规划（Kadane算法）。不要用二维数组（O(N^2)会爆内存），要用O(N)的一维DP或O(1)的滚动变量。状态转移方程：dp[i] = Math.max(nums[i], dp[i-1] + nums[i])，含义是“如果前一个累加和大于0就接上，否则就以当前数字重新开始”。 |
| 0054 | [Spiral Matrix](https://leetcode.cn/problems/spiral-matrix/) | [Java(Mymethod)](0054-spiral-matrix/Solution_MyMethod.java), [Java(Simulationbydirectionvectorrotation)](0054-spiral-matrix/Solution_SimulationByDirectionVectorRotation.java) | Medium | 方法一：模拟转圈法：使用方向数组并标记访问过的元素，通过转向规则控制遍历。方法二：方向向量旋转模拟法，通过旋转方向向量实现顺时针遍历矩阵。![image-20251024200657296](https://lskypro.puber.top/i/2025/10/24/68fb6be8ed224.png) |
| 0058 | [Length Of Last Word](https://leetcode.cn/problems/length-of-last-word/) | [Java(Backwardtraversal)](0058-length-of-last-word/Solution_BackwardTraversal.java) | Easy | 题目是求字符串的最后一个单词的长度，所以此题的关键就是从字符串的尾部开始遍历 |
| 0059 | [Spiral Matrix Ii](https://leetcode.cn/problems/spiral-matrix-ii/) | [Java(Simulaton)](0059-spiral-matrix-ii/Solution_Simulaton.java) | Medium |  |
| 0061 | [Rotate List](https://leetcode.cn/problems/rotate-list/) | [Java(Cycleformationandbreakapproach)](0061-rotate-list/Solution_CycleFormationAndBreakApproach.java) | Medium | 使用成环破环法解决，先成环，然后计算偏移量，然后在偏移后的位置破环 |
| 0063 | [Unique Paths Ii](https://leetcode.cn/problems/unique-paths-ii/) | [Java(Mymethod)](0063-unique-paths-ii/Solution_MyMethod.java) | Medium |  |
| 0066 | [Plus One](https://leetcode.cn/problems/plus-one/) | [Java(Mymethod)](0066-plus-one/Solution_MyMethod.java) | Easy |  |
| 0067 | [Add Binary](https://leetcode.cn/problems/add-binary/) | [Java(Bitoperation)](0067-add-binary/Solution_BitOperation.java), [Java(Simulationmethod)](0067-add-binary/Solution_SimulationMethod.java) | Easy | 使用模拟法从字符串的尾部逐个相加到头部，使用StringBuilder保存相加结果，返回时候将StringBuilder反转即为最后的结果。模拟法的优点是不会遇到整数溢出的问题。 |
| 0069 | [Sqrtx](https://leetcode.cn/problems/sqrtx/) | [Java(Binarysearch)](0069-sqrtx/Solution_BinarySearch.java), [Java(Newtoniterationmethod)](0069-sqrtx/Solution_NewtonIterationMethod.java) | Easy | 可以使用二分查找方，也可以使用牛顿迭代法。[牛顿迭代法详解](https://oi-wiki.org/math/numerical/newton/) |
| 0070 | [Climbing Stairs](https://leetcode.cn/problems/climbing-stairs/) | [Java(Recursion)](0070-climbing-stairs/Solution_Recursion.java) | Easy |  |
| 0071 | [Simplify Path](https://leetcode.cn/problems/simplify-path/) | [Java(Stack)](0071-simplify-path/Solution_Stack.java) | Medium | 根据题意，遇到'..'需要回退到上一级目录，于是我们自然想到栈后进先出的特性，使用栈（Stack）数据结构来处理路径简化问题。遍历路径字符串，遇到'..'时弹出栈顶元素（表示返回上一级目录），遇到'.'或空字符串时忽略，其他有效目录名则入栈。最后将栈中的元素拼接成简化后的路径。ArrayList不是栈结构，但是如果只使用add和removeLast方法，也可以模拟栈的行为。 |
| 0073 | [Set Matrix Zeroes](https://leetcode.cn/problems/set-matrix-zeroes/) | [Java(Mymethod)](73-set-matrix-zeroes/Solution_MyMethod.java) | Medium |  |
| 0077 | [Combinations](https://leetcode.cn/problems/combinations/) | [Java(Backtrack)](0077-combinations/Solution_Backtrack.java) | Medium | 看到这类组合问题，第一反应就是使用回溯法来解决。关键在于如何设计回溯函数的参数和终止条件。这里我们敏锐的察觉到所有的组合都是递增的，所以可以使用一个start索引来控制每次选择的起点，避免重复选择和无效选择。 |
| 0083 | [Remove Duplicates From Sorted List](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/) | [Java(Traversal)](0083-remove-duplicates-from-sorted-list/Solution_Traversal.java) | Easy | 设定一个指针遍历链表，当当前节点的值等于下一个节点的值时，跳过下一个节点，直到遇到不同值的节点为止。这样就能有效地移除重复节点，保持链表的唯一性。 |
| 0094 | [Binary Tree Inorder Traversal](https://leetcode.cn/problems/binary-tree-inorder-traversal/) | [Java(Iteration)](0094-binary-tree-inorder-traversal/Solution_Iteration.java), [Java(Morris)](0094-binary-tree-inorder-traversal/Solution_Morris.java), [Java(Recursion)](0094-binary-tree-inorder-traversal/Solution_Recursion.java) | Easy | 递归法 : 这是最直观、代码最简洁的解法。迭代法: 使用一个栈来模拟递归的过程。通过循环和栈的辅助，手动控制节点的访问顺序，有效避免了当树的深度过大时可能出现的栈溢出问题。Morris 遍历: 一种空间复杂度为 O(1) 的精妙解法。它不使用递归和栈，而是通过临时修改树中节点的右空指针，建立起“线索”，从而在遍历完左子树后能够顺利地回溯到根节点。 |
| 0098 | [Validate Binary Search Tree](https://leetcode.cn/problems/validate-binary-search-tree/) | [Java(Dfs)](98-validate-binary-search-tree/Solution_Dfs.java) | Medium | 递归上下界法：为每个节点设定合法数值范围（最小下界min，最大上界max），递归验证节点值是否在(min, max)内，左子树范围更新为(min, 当前节点值)，右子树范围更新为(当前节点值, max)。2. 中序遍历法：利用BST中序遍历结果为严格递增序列的特性，在遍历过程中比较当前节点值是否大于前一个节点的值。关键点：不能仅检查节点的直接子节点，需确保整个子树节点满足范围约束；注意处理整数边界值 |
| 0100 | [Same Tree](https://leetcode.cn/problems/same-tree/) | [Java(Iteration)](0100-same-tree/Solution_Iteration.java), [Java(Recursion)](0100-same-tree/Solution_Recursion.java) | Easy | 递归是深度优先的方法，迭代是广度优先的方法。迭代方法使用的队列是LinkedList实现的，可以存储null节点，而ArrayDeque不可以存储null节点。 |
| 0101 | [Symmetric Tree](https://leetcode.cn/problems/symmetric-tree/) | [Java(Iteration)](0101-symmetric-tree/Solution_Iteration.java), [Java(Recursion)](0101-symmetric-tree/Solution_Recursion.java) | Easy | ![image-20251020105336646](https://lskypro.puber.top/i/2025/10/20/68f5a437bb933.png) 递归解法通常是深度优先（DFS）的顺序。它会沿着一条路径深入下去，连续访问的节点（父、子、孙）在内存中的位置可能更接近。迭代解法是广度优先（BFS）的顺序。它在树的各层之间“跳跃”，访问的内存地址可能不连续。 |
| 0102 | [Binary Tree Level Order Traversal](https://leetcode.cn/problems/binary-tree-level-order-traversal/) | [Java(Bfs)](0102-binary-tree-level-order-traversal/Solution_Bfs.java) | Medium | 使用bfs实现二叉树的层序遍历 |
| 0104 | [Maximum Depth Of Binary Tree](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) | [Java(Recursion)](0104-maximum-depth-of-binary-tree/Solution_Recursion.java) | Easy |  |
| 0118 | [Pascals Triangle](https://leetcode.cn/problems/pascals-triangle/) | [Java(Mymethod)](0118-pascals-triangle/Solution_MyMethod.java) | Easy | 这道杨辉三角的题主要是要用到List的get方法来获取上一行的元素，从而计算出当前行的元素值。 |
| 0128 | [Longest Consecutive Sequence](https://leetcode.cn/problems/longest-consecutive-sequence/) | [Java(Hashset)](0128-longest-consecutive-sequence/Solution_HashSet.java) | Medium | 使用哈希集合是解决这道题目的关键，题目要求时间复杂度为O(n), 所以不可使用暴力算法，因此使用哈希集合以空间换时间。尽管代码在形式上可能包含嵌套循环（例如，外层遍历哈希集合中的数字，内层从序列起点向后查找连续数字），但其时间复杂度为 O(n) 而非 O(n²)。关键在于算法通过预处理（将数字存入哈希集合）实现了 O(1) 的查找效率，且内层循环仅在每个连续序列的起点触发。每个数字最多被访问两次（一次在外层遍历中，一次在序列查找中），所有内层循环的总操作次数与数组长度 n 成正比，因此整体复杂度为线性 |
| 0136 | [Single Number](https://leetcode.cn/problems/single-number/) | [Java(Xor)](0136-single-number/Solution_Xor.java) | Easy | 题目要求只使用常量的额外空间，所以不能使用哈希表存储每个数字出现的次数。本题利用了异或运算的性质，a ^ a = 0, 0 ^ a = a |
| 0200 | [Number Of Islands](https://leetcode.cn/problems/number-of-islands/) | [Java(Dfs)](0200-number-of-islands/Solution_Dfs.java) | Medium |  |
| 0226 | [Invert Binary Tree](https://leetcode.cn/problems/invert-binary-tree/) | [Java(Dfs)](0226-invert-binary-tree/Solution_Dfs.java), [Java(Recursion)](0226-invert-binary-tree/Solution_Recursion.java) | Easy |  |
| 0240 | [Search A 2D Matrix Ii](https://leetcode.cn/problems/search-a-2d-matrix-ii/) | [Java(Binarysearch)](240-search-a-2d-matrix-ii/Solution_BinarySearch.java), [Java(Binarysearchtree)](240-search-a-2d-matrix-ii/Solution_BinarySearchTree.java) | Medium | 这题的最优解法是将矩阵看做是一个二叉搜索树，然后使用类似于二叉搜索树的搜索方法来查找目标值。具体来说，从矩阵的右上角开始，如果当前元素等于目标值，则返回true；如果当前元素大于目标值，则向左移动一列（相当于在二叉搜索树中往左子树走）；如果当前元素小于目标值，则向下移动一行（相当于在二叉搜索树中往右子树走）。这样可以有效地缩小搜索范围，直到找到目标值或者超出矩阵边界为止。 |
| 0283 | [Move Zeroes](https://leetcode.cn/problems/move-zeroes/) | [Java(Twopointers)](283-move-zeroes/Solution_TwoPointers.java) | Easy | 去除数组中的0，题目要求必须在原数组上操作，不能使用额外的数组空间。使用双指针法（快慢指针），快指针遍历数组，慢指针记录非零元素的末尾位置。当快指针遇到非零元素时，将其赋值给慢指针位置，并将慢指针后移，最后将慢指针之后的位置全部置零。 |
| 0290 | [Word Pattern](https://leetcode.cn/problems/word-pattern/) | [Java(Hashmap)](0290-word-pattern/Solution_HashMap.java) | Easy | 这道题的关键是如何保证模式字符串中的字符和字符串中的单词间的一一对应关系。为此，我们使用了两个哈希表：一个用于存储字符到单词的映射，另一个用于存储单词到字符的映射。在遍历模式字符串和字符串时，我们同时检查这两个映射表，以确保每个字符和单词之间的映射关系是一致的。如果发现任何不一致的情况，我们就返回false。如果遍历完成后没有发现不一致的映射关系，则返回true，表示字符串遵循给定的模式。另外一个需要注意的就是注意模式串的长度和字符串中的单词个数是否一致，不一致的话直接返回false。 |
| 1578 | [Minimum Time To Make Rope Colorful](https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/) | [Java(Mymethod)](1578-minimum-time-to-make-rope-colorful/Solution_MyMethod.java) | Medium | 维护一个变量记录当前连续相同颜色气球中的最大时间成本，确保只保留成本最大的气球。 |
| 2048 | [Next Greater Numerically Balanced Number](https://leetcode.cn/problems/next-greater-numerically-balanced-number/) | [Java(Dfsaddbinarysearch)](2048-next-greater-numerically-balanced-number/Solution_DfsAddBinarySearch.java), [Java(Enumeration)](2048-next-greater-numerically-balanced-number/Solution_Enumeration.java) | Medium | 使用枚举法遍历数字，然后判断每个数字是不是数值平衡数，在此过程中需要统计数字中的每个数字符出现的次数，这里不使用哈希表，而是使用数组，因为数字范围是固定的0-9，所以数组的元素的index对应数字，value对应数字出现的次数。也可以使用打表法，使用回溯预先计算出所有的数值平衡数，然后排序，然后使用二分查找法在表中查找大于n的最小数值平衡数。 |
| 2125 | [Number Of Laser Beams In A Bank](https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/) | [Java(Fluentapi​​)](2125-number-of-laser-beams-in-a-bank/Solution_FluentAPI​​.java), [Java(Mymethod)](2125-number-of-laser-beams-in-a-bank/Solution_MyMethod.java) | Medium | 标准答案使用了函数编程的思想，使用了int cnt = (int) line.chars().filter(ch -> ch == '1').count()来统计每一行中'1'的个数，非常简洁。另一种思路是使用传统的for循环遍历字符串，遇到'1'就计数器加一。 |
| 2257 | [Count Unguarded Cells In The Grid](https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/) | [Java(Simulation)](2257-count-unguarded-cells-in-the-grid/Solution_Simulation.java) | Medium | 使用模拟法解决守卫保护单元格的问题。首先构建一个矩阵表示网格状态，标记守卫和墙的位置。然后对于每个守卫，沿四个方向（上、下、左、右）遍历，直到遇到墙或另一个守卫，标记这些路径上的单元格为受保护状态。最后统计未被保护且非墙非守卫的单元格数量。关键点在于正确处理边界条件和避免重复标记。 |
| 3217 | [Delete Nodes From Linked List Present In Array](https://leetcode.cn/problems/delete-nodes-from-linked-list-present-in-array/) | [Java(Mymethod)](3217-delete-nodes-from-linked-list-present-in-array/Solution_MyMethod.java) | Medium | 题目要求删去链表中所有在数组中出现的节点。可以使用哈希集合（HashSet）存储数组中的值，以便快速查找。然后遍历链表，使用双指针（前驱节点和当前节点）来删除匹配的节点。为了简化边界情况的处理（头结点可能被移除），可以引入一个虚拟头节点（dummy node）。 |
| 3289 | [The Two Sneaky Numbers Of Digitville](https://leetcode.cn/problems/the-two-sneaky-numbers-of-digitville/) | [Java(Hash)](3289-the-two-sneaky-numbers-of-digitville/Solution_Hash.java), [Java(Locationmarking)](3289-the-two-sneaky-numbers-of-digitville/Solution_LocationMarking.java), [Java(Math)](3289-the-two-sneaky-numbers-of-digitville/Solution_Math.java), [Java(Mymethod)](3289-the-two-sneaky-numbers-of-digitville/Solution_MyMethod.java), [Java(Sort)](3289-the-two-sneaky-numbers-of-digitville/Solution_Sort.java) | Easy | 这题如果要使用额外空间的话，可以使用哈希集合（HashSet）来记录已经出现过的数字，然后在遍历数组时检查当前数字是否已经在集合中出现过，从而找到重复的数字。对于缺失的数字，可以通过计算总和的方式来找出。另一种不使用额外空间的方法是利用数组本身作为哈希表，通过将数字对应的索引位置加上N（数组长度）作为标记，从而找到重复和缺失的数字。 |
| 3318 | [Find X Sum Of All K Long Subarrays I](https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-i/) | [Java(Heap)](3318-find-x-sum-of-all-k-long-subarrays-i/Solution_Heap.java) | Easy | 本题的一个子问题是如何找到前x大的元素，这是一个典型的**top-k问题**。可以使用最小堆（Min-Heap）来高效地解决这个问题。具体步骤如下：1. 初始化一个大小为x的最小堆；2. 遍历数组，对于每个元素，如果堆的大小小于x，则将元素加入堆中；如果堆已满且当前元素大于堆顶元素，则弹出堆顶并将当前元素加入堆中；3. 遍历完成后，堆中即为前x大的元素。 |
| 3732 | [Maximum Product Of Three Elements After One Replacement](https://leetcode.cn/problems/maximum-product-of-three-elements-after-one-replacement/) | [Java(Improved)](3732-maximum-product-of-three-elements-after-one-replacement/Solution_Improved.java), [Java(Mymethod)](3732-maximum-product-of-three-elements-after-one-replacement/Solution_MyMethod.java) | Medium | 这道题的关键是要找到nums中绝对值最大和第二大的元素，然后根据它们的符号来决定最终的最大正数和最小负数。具体步骤如下：首先初始化前两个元素，确保firstMax的绝对值不小于secondMax；接着从第三个元素开始遍历，若当前元素绝对值大于firstMax，则更新secondMax为原firstMax，并更新firstMax为当前元素；若其绝对值仅大于secondMax，则只更新secondMax。 |
| 3740 | [Minimum Distance Between Three Equal Elements I](https://leetcode.cn/problems/minimum-distance-between-three-equal-elements-i/) | [Java(Fastslowpointers)](3740-minimum-distance-between-three-equal-elements-i/Solution_FastSlowPointers.java) | Easy | 本题使用快慢指针，优化见3741解法。 |
| 3741 | [Minimum Distance Between Three Equal Elements Ii](https://leetcode.cn/problems/minimum-distance-between-three-equal-elements-ii/) | [Java(Hashmap)](3741-minimum-distance-between-three-equal-elements-ii/Solution_HashMap.java) | Medium | **注意**:尽管代码在形式上表现为一个嵌套循环（外层遍历HashMap的键，内层遍历每个键对应的索引列表），其时间复杂度本质上却是 O(n) 而非 O(n²)。其关键原理在于，所有内层循环遍历的“工作量”总和等于原始数组的长度 n。这是因为 HashMap 已经通过预处理将数组的每个索引按其数值进行了分组存放，每个索引只属于一个列表，且只被处理一次。因此，从分摊分析的角度来看，虽然外层循环遍历的是不同的数字，内层循环处理的是这些数字对应的所有索引，但所有内层循环体执行的总次数，就是所有索引列表中索引的总数，这恰好等于数组的长度 n。所以，这种通过预处理将数据分组、再对每组数据进行处理的模式，即使表现为嵌套循环，其总操作次数也只与数据总量 n 成正比，因此是线性复杂度 O(n)，这与简单的双重循环遍历整个数组的 O(n²) 算法有着本质区别。 |