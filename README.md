# My Algo Journey

此代码库记录了我的 LeetCode 算法与数据结构学习之旅。它不仅是我的个人解题日志，更是日后参考的知识宝库，旨在不断磨练逻辑思维，精进编程技艺。

## Progress

| # | Title | Solution | Difficulty | Notes |
|---|---|---|---|---|
| 0020 | [Valid Parentheses](https://leetcode.cn/problems/valid-parentheses/) | [Java(Stackandmap)](0020-valid-parentheses/Solution_StackAndMap.java), [Java(Stackonly)](0020-valid-parentheses/Solution_StackOnly.java) | Easy | 使用栈（Stack）是解决此问题的经典方法。遍历字符串，遇到左括号入栈，遇到右括号则与栈顶元素匹配出栈。 |
| 0021 | [Merge Two Sorted Lists](https://leetcode.cn/problems/merge-two-sorted-lists/) | [Java(Iteration)](0021-merge-two-sorted-lists/Solution_Iteration.java), [Java(Recursion)](0021-merge-two-sorted-lists/Solution_Recursion.java) | Easy | 迭代法使用虚拟头节点（dummy node）简化链表操作；递归法则代码更简洁。 |
| 0022 | [Generate Parentheses](https://leetcode.cn/problems/generate-parentheses/) | [Java(Pruningbacktrack)](0022-generate-parentheses/Solution_PruningBacktrack.java), [Java(Recursion)](0022-generate-parentheses/Solution_Recursion.java) | Medium | 回溯法是解决此问题的标准解法。通过剪枝优化：当左括号数量未满n时可添加 '('；当右括号数量小于左括号时可添加 ')'，从而确保所有组合都有效。 |
| 0023 | [Merge K Sorted Lists](https://leetcode.cn/problems/merge-k-sorted-lists/) | [Java(Bruteforce)](0023-merge-k-sorted-lists/Solution_BruteForce.java), [Java(Divideandconquer)](0023-merge-k-sorted-lists/Solution_DivideAndConquer.java), [Java(Priorityqueue)](0023-merge-k-sorted-lists/Solution_PriorityQueue.java), [Java(Sequentialmerge)](0023-merge-k-sorted-lists/Solution_SequentialMerge.java) | Hard | 暴力法​​直接收集排序，简单但低效；​​顺序合并法​​通过两两合并简化问题，易于理解；​​分治法​​应用归并思想，达到O(N log k)最优时间复杂度，稳定可靠；​​优先队列法​​利用最小堆动态获取最小值，代码简洁，面试首选。 |
| 0024 | [Swap Nodes In Pairs](https://leetcode.cn/problems/swap-nodes-in-pairs/) | [Java(Iteration)](0024-swap-nodes-in-pairs/Solution_Iteration.java), [Java(Recursion)](0024-swap-nodes-in-pairs/Solution_Recursion.java) | Medium | 迭代法可借助虚拟头节点，通过指针操作两两交换节点。递归法则将问题分解为“交换当前两个节点”和“处理剩余链表”的子问题，逻辑更清晰。 |
| 0025 | [Reverse Nodes In K Group](https://leetcode.cn/problems/reverse-nodes-in-k-group/) | [Java(Iteration)](0025-reverse-nodes-in-k-group/Solution_Iteration.java) | Hard | “反转链表”的升级版。核心思路是分组处理，然后将其与前后部分连接起来。需要精细控制多个指针。 |
| 0026 | [Remove Duplicates From Sorted Array](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/) | [Java(Fastslowpointer)](0026-remove-duplicates-from-sorted-array/Solution_FastSlowPointer.java) | Easy | 使用双指针解法--快慢指针。 |
| 0027 | [Remove Element](https://leetcode.cn/problems/remove-element/) | [Java(Fastslowpointer)](0027-remove-element/Solution_FastSlowPointer.java), [Java(Twopointersfromoppositeends)](0027-remove-element/Solution_TwoPointersFromOppositeEnds.java) | Easy | 快慢指针的本质是将所有不需要移除的元素，按照原有的相对顺序，全部搬运到了数组的前面。 首位双指针（对撞指针）的方法相较与快慢指针的优势在于大幅减少了元素的赋值次数，仅在遇到目标元素时才操作，但会打乱元素的原始相对顺序。 |
| 0028 | [Find The Index Of The First Occurrence In A String](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/) | [Java(Iteration)](0028-find-the-index-of-the-first-occurrence-in-a-string/Solution_Iteration.java), [Java(Kmp)](0028-find-the-index-of-the-first-occurrence-in-a-string/Solution_Kmp.java) | Easy | 暴力法简单但是低效，不适合大量长文本的字符串匹配。kmp算法只需遍历一遍字符串 |
| 0029 | [Divide Two Integers](https://leetcode.cn/problems/divide-two-integers/) | [Java(Bitwisedivision)](0029-divide-two-integers/Solution_BitwiseDivision.java) | Medium | 该算法通过位运算实现整数除法，核心是处理符号后转为负数计算以避免溢出，并通过位移加速减法过程。关键点包括处理 Integer.MIN_VALUE / -1的溢出，以及内层循环中检查位移边界防止溢出 |
| 0035 | [Search Insert Position](https://leetcode.cn/problems/search-insert-position/) | [Java(Binarysearch)](0035-search-insert-position/Solution_BinarySearch.java) | Easy | 题目要求必须使用时间复杂度为 O(log n) 的算法，下意识想到二分查找的方法。 |
| 0036 | [Valid Sudoku](https://leetcode.cn/problems/valid-sudoku/) | [Java(Bitwiseoperation)](0036-valid-sudoku/Solution_BitwiseOperation.java), [Java(Mymethod)](0036-valid-sudoku/Solution_MyMethod.java) | Medium | 核心思路是通过一次遍历，使用数组（或哈希集合）分别记录每行、每列、每个3x3宫格中数字的出现情况。关键点是计算宫格索引：box_index = (i // 3) * 3 + j // 3。优化方向包括使用位运算压缩空间。 |
| 0045 | [Jump Game Ii](https://leetcode.cn/problems/jump-game-ii/) | [Java(Bfs)](0045-jump-game-ii/Solution_Bfs.java), [Java(Greedy)](0045-jump-game-ii/Solution_Greedy.java) | Medium |  |
| 0046 | [Permutations](https://leetcode.cn/problems/permutations/) | [Java(Backtrack)](0046-permutations/Solution_Backtrack.java) | Medium | 使用回溯算法生成数组的全部排列，通过used数组标记已选元素避免重复，并在找到完整排列时保存路径副本，确保结果正确。其时间复杂度为O(n × n!) |
| 0047 | [Permutations Ii](https://leetcode.cn/problems/permutations-ii/) | [Java(Backtrack)](0047-permutations-ii/Solution_Backtrack.java) | Medium | 在 46 题回溯算法的基础上，增加了对重复元素排列的去重处理。关键在于先对数组排序，然后在回溯的 for 循环中增加剪枝逻辑（i > 0 && nums[i] == nums[i-1] && !used[i-1]），确保相同元素在同一层只被选择一次，避免产生重复排列。时间复杂度仍为 O(n × n!)。 |
| 0048 | [Rotate Image](https://leetcode.cn/problems/rotate-image/) | [Java(Transposeandreverse)](0048-rotate-image/Solution_TransposeAndReverse.java) | Medium | 原地旋转矩阵。使用'分解动作'的技巧，将一次复杂的'顺时针旋转90度'分解为两次简单的原地操作：1. 先沿主对角线（左上到右下）翻转矩阵；2. 再对矩阵的每一行进行左右水平翻转。 |
| 0050 | [Powx N](https://leetcode.cn/problems/powx-n/) | [Java(Iterationfastpower)](0050-powx-n/Solution_IterationFastPower.java), [Java(Mymethod)](0050-powx-n/Solution_MyMethod.java), [Java(​​Recursive​​Fastpower)](0050-powx-n/Solution_​​Recursive​​FastPower.java) | Medium | 实现 pow(x, n)。考察快速幂算法（Exponentiation by Squaring）。关键思路：当 n 为偶数时，pow(x, n) = pow(x*x, n/2)；当 n 为奇数时，pow(x, n) = x * pow(x, n-1)。通过递归或迭代方式实现，时间复杂度从 O(n) 降到 O(log n)。注意处理 n 为负数的情况（结果取 1/pow(x, -n)）。 |
| 0054 | [Spiral Matrix](https://leetcode.cn/problems/spiral-matrix/) | [Java(Mymethod)](0054-spiral-matrix/Solution_MyMethod.java), [Java(Simulationbydirectionvectorrotation)](0054-spiral-matrix/Solution_SimulationByDirectionVectorRotation.java) | Medium | 方法一：模拟转圈法：使用方向数组并标记访问过的元素，通过转向规则控制遍历。方法二：方向向量旋转模拟法，通过旋转方向向量实现顺时针遍历矩阵。![image-20251024200657296](https://lskypro.puber.top/i/2025/10/24/68fb6be8ed224.png) |
| 0058 | [Length Of Last Word](https://leetcode.cn/problems/length-of-last-word/) | [Java(Backwardtraversal)](0058-length-of-last-word/Solution_BackwardTraversal.java) | Easy | 题目是求字符串的最后一个单词的长度，所以此题的关键就是从字符串的尾部开始遍历 |
| 0059 | [Spiral Matrix Ii](https://leetcode.cn/problems/spiral-matrix-ii/) | [Java(Simulaton)](0059-spiral-matrix-ii/Solution_Simulaton.java) | Medium |  |
| 0061 | [Rotate List](https://leetcode.cn/problems/rotate-list/) | [Java(Cycleformationandbreakapproach)](0061-rotate-list/Solution_CycleFormationAndBreakApproach.java) | Medium | 使用成环破环法解决，先成环，然后计算偏移量，然后在偏移后的位置破环 |
| 0063 | [Unique Paths Ii](https://leetcode.cn/problems/unique-paths-ii/) | [Java(Mymethod)](0063-unique-paths-ii/Solution_MyMethod.java) | Medium |  |
| 0066 | [Plus One](https://leetcode.cn/problems/plus-one/) | [Java(Mymethod)](0066-plus-one/Solution_MyMethod.java) | Easy |  |
| 0067 | [Add Binary](https://leetcode.cn/problems/add-binary/) | [Java(Bitoperation)](0067-add-binary/Solution_BitOperation.java), [Java(Simulationmethod)](0067-add-binary/Solution_SimulationMethod.java) | Easy | 使用模拟法从字符串的尾部逐个相加到头部，使用StringBuilder保存相加结果，返回时候将StringBuilder反转即为最后的结果。模拟法的优点是不会遇到整数溢出的问题。 |
| 0069 | [Sqrtx](https://leetcode.cn/problems/sqrtx/) | [Java(Binarysearch)](0069-sqrtx/Solution_BinarySearch.java), [Java(Newtoniterationmethod)](0069-sqrtx/Solution_NewtonIterationMethod.java) | Easy | 可以使用二分查找方，也可以使用牛顿迭代法。[牛顿迭代法详解](https://oi-wiki.org/math/numerical/newton/) |
| 0070 | [Climbing Stairs](https://leetcode.cn/problems/climbing-stairs/) | [Java(Recursion)](0070-climbing-stairs/Solution_Recursion.java) | Easy |  |
| 0077 | [Combinations](https://leetcode.cn/problems/combinations/) | [Java(Backtrack)](0077-combinations/Solution_Backtrack.java) | Medium | 看到这类组合问题，第一反应就是使用回溯法来解决。关键在于如何设计回溯函数的参数和终止条件。这里我们敏锐的察觉到所有的组合都是递增的，所以可以使用一个start索引来控制每次选择的起点，避免重复选择和无效选择。 |
| 0083 | [Remove Duplicates From Sorted List](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/) | [Java(Traversal)](0083-remove-duplicates-from-sorted-list/Solution_Traversal.java) | Easy | 设定一个指针遍历链表，当当前节点的值等于下一个节点的值时，跳过下一个节点，直到遇到不同值的节点为止。这样就能有效地移除重复节点，保持链表的唯一性。 |
| 0094 | [Binary Tree Inorder Traversal](https://leetcode.cn/problems/binary-tree-inorder-traversal/) | [Java(Iteration)](0094-binary-tree-inorder-traversal/Solution_Iteration.java), [Java(Morris)](0094-binary-tree-inorder-traversal/Solution_Morris.java), [Java(Recursion)](0094-binary-tree-inorder-traversal/Solution_Recursion.java) | Easy | 递归法 : 这是最直观、代码最简洁的解法。迭代法: 使用一个栈来模拟递归的过程。通过循环和栈的辅助，手动控制节点的访问顺序，有效避免了当树的深度过大时可能出现的栈溢出问题。Morris 遍历: 一种空间复杂度为 O(1) 的精妙解法。它不使用递归和栈，而是通过临时修改树中节点的右空指针，建立起“线索”，从而在遍历完左子树后能够顺利地回溯到根节点。 |
| 0100 | [Same Tree](https://leetcode.cn/problems/same-tree/) | [Java(Iteration)](0100-same-tree/Solution_Iteration.java), [Java(Recursion)](0100-same-tree/Solution_Recursion.java) | Easy | 递归是深度优先的方法，迭代是广度优先的方法。迭代方法使用的队列是LinkedList实现的，可以存储null节点，而ArrayDeque不可以存储null节点。 |
| 0101 | [Symmetric Tree](https://leetcode.cn/problems/symmetric-tree/) | [Java(Iteration)](0101-symmetric-tree/Solution_Iteration.java), [Java(Recursion)](0101-symmetric-tree/Solution_Recursion.java) | Easy | ![image-20251020105336646](https://lskypro.puber.top/i/2025/10/20/68f5a437bb933.png) 递归解法通常是深度优先（DFS）的顺序。它会沿着一条路径深入下去，连续访问的节点（父、子、孙）在内存中的位置可能更接近。迭代解法是广度优先（BFS）的顺序。它在树的各层之间“跳跃”，访问的内存地址可能不连续。 |
| 0102 | [Binary Tree Level Order Traversal](https://leetcode.cn/problems/binary-tree-level-order-traversal/) | [Java(Bfs)](0102-binary-tree-level-order-traversal/Solution_Bfs.java) | Medium | 使用bfs实现二叉树的层序遍历 |
| 0104 | [Maximum Depth Of Binary Tree](https://leetcode.cn/problems/maximum-depth-of-binary-tree/) | [Java(Recursion)](0104-maximum-depth-of-binary-tree/Solution_Recursion.java) | Easy |  |
| 0118 | [Pascals Triangle](https://leetcode.cn/problems/pascals-triangle/) | [Java(Mymethod)](0118-pascals-triangle/Solution_MyMethod.java) | Easy | 这道杨辉三角的题主要是要用到List的get方法来获取上一行的元素，从而计算出当前行的元素值。 |
| 0136 | [Single Number](https://leetcode.cn/problems/single-number/) | [Java(Xor)](0136-single-number/Solution_Xor.java) | Easy | 题目要求只使用常量的额外空间，所以不能使用哈希表存储每个数字出现的次数。本题利用了异或运算的性质，a ^ a = 0, 0 ^ a = a |
| 0200 | [Number Of Islands](https://leetcode.cn/problems/number-of-islands/) | [Java(Dfs)](0200-number-of-islands/Solution_Dfs.java) | Medium |  |
| 0226 | [Invert Binary Tree](https://leetcode.cn/problems/invert-binary-tree/) | [Java(Dfs)](0226-invert-binary-tree/Solution_Dfs.java), [Java(Recursion)](0226-invert-binary-tree/Solution_Recursion.java) | Easy |  |
| 0290 | [Word Pattern](https://leetcode.cn/problems/word-pattern/) | [Java(Hashmap)](0290-word-pattern/Solution_HashMap.java) | Easy | 这道题的关键是如何保证模式字符串中的字符和字符串中的单词间的一一对应关系。为此，我们使用了两个哈希表：一个用于存储字符到单词的映射，另一个用于存储单词到字符的映射。在遍历模式字符串和字符串时，我们同时检查这两个映射表，以确保每个字符和单词之间的映射关系是一致的。如果发现任何不一致的情况，我们就返回false。如果遍历完成后没有发现不一致的映射关系，则返回true，表示字符串遵循给定的模式。另外一个需要注意的就是注意模式串的长度和字符串中的单词个数是否一致，不一致的话直接返回false。 |
| 2125 | [Number Of Laser Beams In A Bank](https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/) | [Java(Fluentapi​​)](2125-number-of-laser-beams-in-a-bank/Solution_FluentAPI​​.java), [Java(Mymethod)](2125-number-of-laser-beams-in-a-bank/Solution_MyMethod.java) | Medium | 标准答案使用了函数编程的思想，使用了int cnt = (int) line.chars().filter(ch -> ch == '1').count()来统计每一行中'1'的个数，非常简洁。另一种思路是使用传统的for循环遍历字符串，遇到'1'就计数器加一。 |